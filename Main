import java.util.LinkedList;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws InvalidStudentIDException, InvalidStudentNameException {
        StudentManager manager = new StudentManager(); //Problem
        LinkedList<Student> studentLinkedList = new LinkedList<>();
        Scanner scanner  = new Scanner(System.in);
        Predictor predictor = new Predictor();
        boolean running = true;

        while(running){
            System.out.println("\n1. Add Undergraduate Student");
            System.out.println("2. Add Graduate Student");
            System.out.println("3. Display All Stidents");
            System.out.println("4. Save to FIle");
            System.out.println("5. Load from File");
            System.out.println("6. Predict Student Performance");
            System.out.println("7. Exit");
            System.out.println("Choose an option: ");
            int choice = scanner.nextInt();
            scanner.nextLine(); //consume the newline


            String id;
            String name;
            double gpa;
            String major;
            String thesisTopic;
            int credits;

            switch(choice){
                case 1:
                    System.out.print("Enter ID: ");
                    id = scanner.nextLine();
//                        scanner.nextLine();
                    System.out.print("Enter Name: ");
                    name = scanner.nextLine();
                    System.out.print("Enter GPA: ");
                    gpa = scanner.nextDouble();
                    System.out.print("Enter Credits: ");
                    credits = scanner.nextInt();
                    scanner.nextLine();
                    System.out.print("Enter Major: ");
                    major = scanner.nextLine();
                    Student undergrad= new UnderGraduateStudent(name,id, gpa, credits, major);

                    manager.addStudent(undergrad);
                    break;
                case 2:
                    System.out.print("Enter ID: ");
                    id = scanner.nextLine();
                    System.out.print("Enter Name: ");
                    name = scanner.nextLine();
                    System.out.print("Enter GPA: ");
                    gpa = scanner.nextDouble();
                    scanner.nextLine();
                    System.out.print("Enter Credits: ");
                    credits = scanner.nextInt();
                    scanner.nextLine();
                    System.out.print("Enter Major: ");
                    major = scanner.nextLine();
                    System.out.print("Enter Thesis Topic: ");
                    thesisTopic = scanner.nextLine();
                    Student grad= new GraduateStudent(name,id, gpa, credits, major,thesisTopic);

                    manager.addStudent(grad);
                    break;
                case 3:
                    manager.displayAll();
                    break;
                case 4:
                    manager.saveStudent("Student.dat");
                    break;
                case 5:
                    manager.loadStudentData("Student.dat");
                    break;
                case 6:
                    if(manager.getStudents().isEmpty()){
                        System.out.println("No students available for prediction.");
                    } else {
                        for(Student s : manager.getStudents()){
                            String result = predictor.studentPredictor(s);
                            System.out.println(s + " → Prediction: " + result);
                        }
                    }
                    break;
                case 7:
                    running = false;
                    break;
                default:
                    System.out.println("Invalid Choice");
            }
        }
        scanner.close();
        System.out.println("Program Successfully Exited.");
    }
}

READ ME: (Pt.5)
/*
How arrays, ArrayLists, linked lists support static vs. dynamic datasets in AI workflows.
Arrays: Arrays are best for static datasets where you know the dataset size when it is being created while also performing
at a fast pace for static datasets.

ArrayLists: ArrayLists are a good all rounder that can be used for static or dynamic data sets because of their level of efficiency.
I would say that they would be more useful in a dynamic data set over a static one because they have the
ability to add and remove data inside of themselves.

LinkedLists: Now Linked lists are the best for Dynamic Datasets since they have the
ability to have nodes that can be added or removed relatively easy at any point. It does have
slower random access but it also has faster insert/deletion at the head and tail. In AI it is very
suitible for data streams or systems where items are often removed and replaced.

Overall: They all have their uses but in terms of what is most useful where when it comes to datasets,
Arrays are best for the static datasets where you know before making it how many belong in the data.
ArrayLists are a good all rounder that could go in either but don't particularily shine as number one,
And lastly LinkedLists are the best for more dynamic lists that require moving parts, or frequent changes whether the
data is removed or added.
*/

/*
The difference between rule-based simulation (what you’ve built) and a true learning-based classifier (e.g., kNN or other ML algorithms).
I have a lot more experience with rules based as you can imagine, but some basic differences I know is
That they while they are easy to understand and very explainable to other people, rules based simulations lack the ability to
adapt and lean unlike Learning based classifiers. Rules based also lacks the ability to improve itself or generalize without direct input from the writer.
On the other hand Learning-Based Classifiers are a bit more self sufficient and can handle more complex problems.
But in return they are a lot harder to understand and explain while also using more data and power.
But once they are running and learning, they will be able to adapt based on previous information it gathererd.
Both of them have their own uses with Learning-Based seeming to be preferable for more complex projects as it is the Dynamic system compared to
rules-based being static. (Wanted to relate it to the above)
*/
/*-------------------------------------------------------------------------------*/
READ ME: (Deliverables)
/*
Our generic linked list design:
Our design first uses nodes as the building blocks of our linked list which we use to store data 
and the link to the next node in the list. This allows us to create a node at the head of the 
list and then work our way down the chain by creating a node at the tail of the list each time
we want to create a new one. This also allows us to search through the list very easily since we
can check each node until we find what we are looking for. We can also convert our linked list into 
an array very easily for whenever we want to do a binary search.

Our sorting/searching algorithms:
For our sorter we used selection sort which goes through the list and finds our smallest 
GPA and then swaps it with the front of the list and repeats this until the end. This sorting 
algorithm has a O(n^2) time complexity since for each student, it compares that student to all the
other ones in the list. We also used a binary search in our program which searches through the array by 
cutting it in half repeatedly. The way this works is that it first sorts the array by name and then it starts 
in the middle and if that is not a match than it checks if it should search ahead or behind itself in the
chain and it repeats this until it finds the correct name. This could have a time complexity of O(1) if 
it finds it in the middle or a time complexity of O(log n) if it does not find it right away because 
it splits in half each time.

Why did we use rule based classification:
In our code we used rule based classification to classify how well each student was doing
based on their GPA. This was done using simple if-else statements to check each GPA in our list. 
We used this method because it simulates the way that real AI models classify data in a simple and predictable way.

How does this build on assignment 1:
This builds on our genre tagging prototype from assignment one by adding in the use of
a linked list which allows us to tag each student with multiple sets of data like their 
GPA and IDs and anything like that in order to expand our codes usage and simulate the way a real 
AI would classify all of our data.
*/
